cmake_minimum_required(VERSION 2.8 FATAL_ERROR)

# suppress Windows warning about policy
cmake_policy(SET CMP0010 OLD)

# do not rebuild if rules (compiler flags) change
set(CMAKE_SKIP_RULE_DEPENDENCY TRUE)

project(GPU-CPU-COMPARE Fortran C CXX)

option(ENABLE_64BIT_INTEGERS  "Enable 64-bit integers"                                    OFF)
option(ENABLE_MPI             "Enable MPI parallelization"                                OFF)
option(ENABLE_SGI_MPT         "Enable SGI MPT parallelization"                            OFF)
option(ENABLE_MPI2_DETECTION  "Enable detection of MPI-2 standard"                        ON)
option(ENABLE_BOUNDS_CHECK    "Enable bounds check"                                       OFF)
option(ENABLE_CODE_COVERAGE   "Enable code coverage"                                      OFF)
option(ENABLE_STATIC_LINKING  "Enable static libraries linking"                           OFF)
option(ENABLE_OLD_LINKER      "Enable static linking with older linkers"                  OFF)
option(ENABLE_XHOST_FLAG_DETECTION "Enable xHost flag detection for Intel compilers"      OFF)
option(ENABLE_SANITY_CHECKS   "Enable configure-time sanity checks"                       ON)
option(ENABLE_CRAY_WRAPPERS   "Enable cray wrappers for BLAS/LAPACK and MPI"              OFF)
#
option(ENABLE_CULA            "Enable CULA library"                                       ON)
option(ENABLE_CUDA            "Enable CUDA library"                                       ON)
#
option(ENABLE_BUILTIN_BLAS   "Enable builtin BLAS implementation (slow)"        OFF)
option(ENABLE_AUTO_BLAS      "Enable CMake to autodetect BLAS"                  ON)
option(ENABLE_BUILTIN_LAPACK "Enable builtin LAPACK implementation (slow)"      OFF)
option(ENABLE_AUTO_LAPACK    "Enable CMake to autodetect LAPACK"                ON)

# python interpreter is required at many places during configuration and build
# for example build with pcmsolver will fail (merging libraries)
# someone can specify minimal version if known
find_package(PythonInterp REQUIRED)

# set python version variable when it is not defined automatically
# this can happen when cmake version is equal or less than 2.8.5
if(NOT PYTHON_VERSION_STRING)
    execute_process(
        COMMAND ${PYTHON_EXECUTABLE} -V
        OUTPUT_VARIABLE PYTHON_VERSION_STRING
        ERROR_VARIABLE PYTHON_VERSION_STRING
    )

    string(REGEX MATCH "Python ([0-9].[0-9].[0-9])" temp "${PYTHON_VERSION_STRING}")
    set(PYTHON_VERSION_STRING ${CMAKE_MATCH_1})
endif()

set(CMAKE_MODULE_PATH
    ${CMAKE_MODULE_PATH}
    ${CMAKE_SOURCE_DIR}/cmake
    ${CMAKE_SOURCE_DIR}/cmake/binary-info
    ${CMAKE_SOURCE_DIR}/cmake/compilers
    ${CMAKE_SOURCE_DIR}/cmake/math
    ${PROJECT_BINARY_DIR}/pamadm-generated           # development code
    ${CMAKE_SOURCE_DIR}/cmake/pamadm-generated       # released code
    ${CMAKE_SOURCE_DIR}/cmake/mpi
    ${CMAKE_SOURCE_DIR}/cmake/testing
    ${CMAKE_SOURCE_DIR}/cmake/testing/autogenerated
    )

if(ENABLE_STATIC_LINKING)
    if (NOT ENABLE_OLD_LINKER)
       # Miro: the "-Wl,--no-export-dynamic" flag is only for newer
       # ld-linkers, fix for older linkers
       set(NODYNEXPORT "-Wl,--no-export-dynamic")
    endif()
    if(CMAKE_Fortran_COMPILER_ID MATCHES PGI)
        set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -Bstatic ${NODYNEXPORT}")
    else()
        set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -static ${NODYNEXPORT}")
    endif()
    set(CMAKE_FIND_LIBRARY_SUFFIXES .a)
endif()

set(EXTERNAL_LIBS)

include(ConfigVersion)
include(ConfigArchitecture)
include(ConfigPamadm)
include(ConfigCompilerFlags)
include(ConfigExternal)
include(ConfigOMP)

# math detection
set(BLAS_LANG "Fortran")
set(LAPACK_LANG "Fortran")
set(MKL_COMPILER_BINDINGS ${CMAKE_Fortran_COMPILER_ID})
include(ConfigMath)

include(ConfigMPI)
include(ConfigSafeGuards)
include(GenericMacros)

if(ENABLE_BUILTIN_BLAS)
    add_definitions(-DUSE_BUILTIN_BLAS)
endif()
if(ENABLE_BUILTIN_LAPACK)
    add_definitions(-DUSE_BUILTIN_LAPACK)
endif()

set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY
    ${PROJECT_BINARY_DIR}/lib
    )

set(CMAKE_Fortran_MODULE_DIRECTORY
    ${PROJECT_BINARY_DIR}/modules
    )

# Workaround for strange problem with cilkrts lib
# Intel does not ship the static version of cilkrts
# and for some reason it gets detected and included in these variables
# breaking the static linking buildup with Intel compilers
if (CMAKE_C_IMPLICIT_LINK_LIBRARIES)
# first check if variable nonempty
    list(REMOVE_ITEM CMAKE_C_IMPLICIT_LINK_LIBRARIES   "cilkrts")
endif()
if (CMAKE_CXX_IMPLICIT_LINK_LIBRARIES)
# first check if variable nonempty
    list(REMOVE_ITEM CMAKE_CXX_IMPLICIT_LINK_LIBRARIES "cilkrts")
endif()

if(ENABLE_64BIT_INTEGERS)
    add_definitions(-DINT_STAR8)
endif()
# forward CPP directly to the code
set(CPP)
if(NOT "${CPP}" STREQUAL "")
    add_definitions(${CPP})
endif()

#include(ConfigGPU)
if(ENABLE_CUDA)
    find_package(CUDA)
    if(CUDA_FOUND)
      add_definitions(-DUSE_CUBLAS)
      message("CUDA_INCLUDE_DIRS=${CUDA_INCLUDE_DIRS}")
      message("CUDA_LIBRARIES=${CUDA_LIBRARIES}")
    else()
      message(FATAL "CUDA not found !")
    endif()
endif()
if(ENABLE_CULA)
    find_package(CULA)
    if(CUDA_FOUND)
      add_definitions(-DUSE_CULA)
      #message("CULA_LIBRARIES=${CULA_LIBRARIES}")
    else()
      message("CULA not found !")
    endif()
endif()

include_directories(
    ${CULA_INCLUDE_DIR}
    ${CUDA_INCLUDE_DIRS}
    ${PROJECT_BINARY_DIR}/modules
    ${PROJECT_BINARY_DIR}
)

set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY)

set(FREE_FORTRAN_SOURCES
    src/fortr_timing.F90
    src/gpu_stuff.F90
    src/utils.F90
)

set(C_SOURCES
    src/gpu_routines.c
)

set(GPUCPU_SOURCES
    ${C_SOURCES}
    ${FREE_FORTRAN_SOURCES}
    ${FIXED_FORTRAN_SOURCES}
    )

add_library(
    gpucpu
    ${GPUCPU_SOURCES}
    ${GENERATED_FILES}
    )

add_library(fortran_cuda "${CUDA_TOOLKIT_ROOT_DIR}/src/fortran.c" "${CUDA_TOOLKIT_ROOT_DIR}/src/fortran.h")

message("CUDA_CUBLAS_LIBRARIES=${CUDA_CUBLAS_LIBRARIES}")

message("CULA_LIBRARY=${CULA_LIBRARY}")
message("CULA_LAPACK_LIBRARY=${CULA_LAPACK_LIBRARY}")

add_executable(gpu-cpu-comparison.x  src/main.F90 ${GPUCPU_SOURCES})
CUDA_ADD_CUBLAS_TO_TARGET(gpu-cpu-comparison.x)

#target_link_libraries(gpu-cpu-comparison.x gpucpu  fortran_cuda   ${CUDA_LIBRARIES}  blas lapack)
#target_link_libraries(gpu-cpu-comparison.x gpucpu  fortran_cuda ${CUDA_LIBRARIES} ${CULA_LIBRARIES} blas lapack)
#target_link_libraries(gpu-cpu-comparison.x gpucpu  ${CUDA_LIBRARIES} ${CULA_LIBRARIES} cublas blas lapack)
#target_link_libraries(gpu-cpu-comparison.x  fortran_cuda ${CUDA_CUBLAS_LIBRARIES} ${CUDA_LIBRARIES} ${CULA_LIBRARIES}  blas lapack)
target_link_libraries(gpu-cpu-comparison.x fortran_cuda ${CUDA_CUBLAS_LIBRARIES} ${CUDA_LIBRARIES} ${CULA_LIBRARIES} blas lapack)


include(ConfigTesting)
#include(ConfigPackaging)

# give information about system, compiler flags, and size of static allocations ...
#set(STATIC_MEM_INFO_BINARIES dirac)

# info what blas and lapack will be used when its variable is not set
if(NOT BLAS_LIBRARIES)
    if(USE_BUILTIN_BLAS)
        # builtin library will be used
        set(BLAS_LIBRARIES_INFO "builtin")
    else()
        # none blas
        set(BLAS_LIBRARIES_INFO "none")
    endif()
endif()
if(NOT LAPACK_LIBRARIES)
    if(USE_BUILTIN_LAPACK)
        # builtin library will be used
        set(LAPACK_LIBRARIES_INFO "builtin")
    else()
        # none lapack
        set(LAPACK_LIBRARIES_INFO "none")
    endif()
endif()

# info that there are no explict libraries set
if(NOT EXPLICIT_LIBS)
    set(EXPLICIT_LIBS_INFO "none")
endif()

# configuration time in UTC
execute_process(
    COMMAND ${PYTHON_EXECUTABLE} -c "import datetime; print(datetime.datetime.utcnow())"
    OUTPUT_VARIABLE CONFIGURATION_TIME
)

# delete \n added by Python print()
string(STRIP ${CONFIGURATION_TIME} CONFIGURATION_TIME)

# list with compiler definitions
get_directory_property(_list_of_definitions DIRECTORY ${CMAKE_SOURCE_DIR} COMPILE_DEFINITIONS)

include(BinaryInfo) # giving information - must be called after everything is set
include(ConfigInfo) # has to come after binary info (dependency: git information)

unset(_list_of_definitions)
