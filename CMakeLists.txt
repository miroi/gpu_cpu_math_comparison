cmake_minimum_required(VERSION 2.8 FATAL_ERROR)

# suppress Windows warning about policy
cmake_policy(SET CMP0010 OLD)

# do not rebuild if rules (compiler flags) change
set(CMAKE_SKIP_RULE_DEPENDENCY TRUE)

project(DIRAC Fortran C CXX)

option(ENABLE_64BIT_INTEGERS  "Enable 64-bit integers"                                    OFF)
option(ENABLE_MPI             "Enable MPI parallelization"                                OFF)
option(ENABLE_SGI_MPT         "Enable SGI MPT parallelization"                            OFF)
option(ENABLE_MPI2_DETECTION  "Enable detection of MPI-2 standard"                        ON)
option(ENABLE_BOUNDS_CHECK    "Enable bounds check"                                       OFF)
option(ENABLE_CODE_COVERAGE   "Enable code coverage"                                      OFF)
option(ENABLE_STATIC_LINKING  "Enable static libraries linking"                           OFF)
option(ENABLE_OLD_LINKER      "Enable static linking with older linkers"                  OFF)
option(ENABLE_XHOST_FLAG_DETECTION "Enable xHost flag detection for Intel compilers"      OFF)
option(ENABLE_SANITY_CHECKS   "Enable configure-time sanity checks"                       ON)
option(ENABLE_CRAY_WRAPPERS   "Enable cray wrappers for BLAS/LAPACK and MPI"              OFF)
option(ENABLE_BENCHMARKS      "Enable benchmarks within the test suite"                   OFF)
option(ENABLE_TUTORIALS       "Enable tutorials within the test suite"                    OFF)

option(ENABLE_BUILTIN_BLAS   "Enable builtin BLAS implementation (slow)"        OFF)
option(ENABLE_AUTO_BLAS      "Enable CMake to autodetect BLAS"                  ON)
option(ENABLE_BUILTIN_LAPACK "Enable builtin LAPACK implementation (slow)"      OFF)
option(ENABLE_AUTO_LAPACK    "Enable CMake to autodetect LAPACK"                ON)

# python interpreter is required at many places during configuration and build
# for example build with pcmsolver will fail (merging libraries)
# someone can specify minimal version if known
find_package(PythonInterp REQUIRED)

# set python version variable when it is not defined automatically
# this can happen when cmake version is equal or less than 2.8.5
if(NOT PYTHON_VERSION_STRING)
    execute_process(
        COMMAND ${PYTHON_EXECUTABLE} -V
        OUTPUT_VARIABLE PYTHON_VERSION_STRING
        ERROR_VARIABLE PYTHON_VERSION_STRING
    )

    string(REGEX MATCH "Python ([0-9].[0-9].[0-9])" temp "${PYTHON_VERSION_STRING}")
    set(PYTHON_VERSION_STRING ${CMAKE_MATCH_1})
endif()

set(CMAKE_MODULE_PATH
    ${CMAKE_MODULE_PATH}
    ${CMAKE_SOURCE_DIR}/cmake
    ${CMAKE_SOURCE_DIR}/cmake/binary-info
    ${CMAKE_SOURCE_DIR}/cmake/compilers
    ${CMAKE_SOURCE_DIR}/cmake/math
    ${PROJECT_BINARY_DIR}/pamadm-generated           # development code
    ${CMAKE_SOURCE_DIR}/cmake/pamadm-generated       # released code
    ${CMAKE_SOURCE_DIR}/cmake/mpi
    ${CMAKE_SOURCE_DIR}/cmake/testing
    ${CMAKE_SOURCE_DIR}/cmake/testing/autogenerated
    )

if(ENABLE_STATIC_LINKING)
    if (NOT ENABLE_OLD_LINKER)
       # Miro: the "-Wl,--no-export-dynamic" flag is only for newer
       # ld-linkers, fix for older linkers
       set(NODYNEXPORT "-Wl,--no-export-dynamic")
    endif()
    if(CMAKE_Fortran_COMPILER_ID MATCHES PGI)
        set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -Bstatic ${NODYNEXPORT}")
    else()
        set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -static ${NODYNEXPORT}")
    endif()
    set(CMAKE_FIND_LIBRARY_SUFFIXES .a)
endif()

set(EXTERNAL_LIBS)

include(ConfigVersion)
include(ConfigArchitecture)
include(ConfigPamadm)
include(Sources) # this has to come before ConfigCompilerFlags
include(ConfigCompilerFlags)
include(ConfigDocumentation)
include(ConfigExternal)
include(ConfigGPU)
include(ConfigOMP)

# math detection
set(BLAS_LANG "Fortran")
set(LAPACK_LANG "Fortran")
set(MKL_COMPILER_BINDINGS ${CMAKE_Fortran_COMPILER_ID})
include(ConfigMath)

include(ConfigMPI)
include(ConfigSafeGuards)
include(GenericMacros)

if(ENABLE_BUILTIN_BLAS)
    add_definitions(-DUSE_BUILTIN_BLAS)
endif()
if(ENABLE_BUILTIN_LAPACK)
    add_definitions(-DUSE_BUILTIN_LAPACK)
endif()

add_custom_command(
    OUTPUT
    ${PROJECT_BINARY_DIR}/fortran_interface.h
    DEPENDS
    gen_fortran_interface_h
    COMMAND
    gen_fortran_interface_h > ${PROJECT_BINARY_DIR}/fortran_interface.h
    )

add_executable(
    gen_fortran_interface_h
    ${PROJECT_SOURCE_DIR}/utils/gen_fortran_interface_h.c
    )

include_directories(
    ${PROJECT_SOURCE_DIR}/src/include
    ${PROJECT_SOURCE_DIR}/src/cfun
    ${PROJECT_BINARY_DIR}/modules
    ${PROJECT_BINARY_DIR}/src/xcfun/fortran
    ${PROJECT_BINARY_DIR}
    )

set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY
    ${PROJECT_BINARY_DIR}/lib
    )

set(CMAKE_Fortran_MODULE_DIRECTORY
    ${PROJECT_BINARY_DIR}/modules
    )

# Workaround for strange problem with cilkrts lib
# Intel does not ship the static version of cilkrts
# and for some reason it gets detected and included in these variables
# breaking the static linking buildup with Intel compilers
if (CMAKE_C_IMPLICIT_LINK_LIBRARIES)
# first check if variable nonempty
    list(REMOVE_ITEM CMAKE_C_IMPLICIT_LINK_LIBRARIES   "cilkrts")
endif()
if (CMAKE_CXX_IMPLICIT_LINK_LIBRARIES)
# first check if variable nonempty
    list(REMOVE_ITEM CMAKE_CXX_IMPLICIT_LINK_LIBRARIES "cilkrts")
endif()


set(GENERATED_FILES
    ${PROJECT_BINARY_DIR}/fortran_interface.h
    )
add_custom_target(dirac_interfaces
    ALL
    DEPENDS
    ${GENERATED_FILES}
)

# set definitions
include(Definitions)

add_definitions(-DPRG_DIRAC)
set(WORK_MEM_WORDS
    "64000000"
    CACHE STRING
    "Work memory in words"
    )
add_definitions(-DINSTALL_WRKMEM=${WORK_MEM_WORDS})
if(ENABLE_MATLAB_LOG)
    add_definitions(-DMOD_MATLAB_LOG)
endif()
if(ENABLE_64BIT_INTEGERS)
    add_definitions(-DINT_STAR8)
endif()
if(ENABLE_LAPACK_QDIAG)
    add_definitions(-DLAPACK_QDIAG)
endif()
# forward CPP directly to the code
set(CPP)
if(NOT "${CPP}" STREQUAL "")
    add_definitions(${CPP})
endif()

# add binary_info.F90
set(GENERATED_FILES
    ${GENERATED_FILES}
    ${CMAKE_BINARY_DIR}/binary_info.F90
    )

set(DIRAC_SOURCES
    ${C_SOURCES}
    ${FREE_FORTRAN_SOURCES}
    ${FIXED_FORTRAN_SOURCES}
    )

add_library(
    dirac
    ${DIRAC_SOURCES}
    ${GENERATED_FILES}
    )

if(DEVELOPMENT_CODE)
    add_dependencies(dirac run_pamadm)
endif()
add_dependencies(dirac generate_binary_info)

set(LIST_OF_EXECUTABLES)
macro(compile_standalone _executable _source LIST_OF_EXECUTABLES)
    add_executable(
        ${_executable}
        ${_source}
    )
    set_property(TARGET ${_executable} PROPERTY LINKER_LANGUAGE Fortran)
    set(LIST_OF_EXECUTABLES
        ${LIST_OF_EXECUTABLES}
        ${_executable}
    )
endmacro()
compile_standalone(dirac.x src/main/main.F90 "${LIST_OF_EXECUTABLES}")

if(ENABLE_UTILITIES)
    compile_standalone(dirac_mointegral_export.x utils/dirac_mointegral_export.F90 "${LIST_OF_EXECUTABLES}")
    compile_standalone(rspread.x                 utils/rspread.F90                 "${LIST_OF_EXECUTABLES}")
    compile_standalone(labread.x                 utils/labread.F90                 "${LIST_OF_EXECUTABLES}")
    compile_standalone(twofit.x                  utils/twofit.F90                  "${LIST_OF_EXECUTABLES}")
    compile_standalone(cfread.x                  utils/cfread.F90                  "${LIST_OF_EXECUTABLES}")
    compile_standalone(vibcal.x                  utils/vibcal.F90                  "${LIST_OF_EXECUTABLES}")
    compile_standalone(polfit.x                  utils/polfit.F90                  "${LIST_OF_EXECUTABLES}")
    compile_standalone(mx2fit.x                  utils/mx2fit.F90                  "${LIST_OF_EXECUTABLES}")
    compile_standalone(diag.x                    utils/diag.F90                    "${LIST_OF_EXECUTABLES}")
    if(ENABLE_RELCCSD_STANDALONE)
        compile_standalone(relccsd.x src/relccsd/ccmain.F "${LIST_OF_EXECUTABLES}")
    endif()
    if(ENABLE_HSCC) # note: this functionality depends on the pam flag
        compile_standalone(hsmrcc.x src/cc_external/hsmrcc/hsmrmain.c "${LIST_OF_EXECUTABLES}")
    endif()
    if(ENABLE_HSFS) # note: this functionality depends on the pam flag
        compile_standalone(hsfscc.x src/cc_external/hsfscc/hsfs_main.F90 "${LIST_OF_EXECUTABLES}")
    endif()
    if(ENABLE_MEM_TEST) #
        compile_standalone(test_allocator.x utils/test_allocator.F90 "${LIST_OF_EXECUTABLES}")
    endif()
endif()

foreach(
    EXECUTABLE
    ${LIST_OF_EXECUTABLES}
    )
    if(${CMAKE_SYSTEM_NAME} STREQUAL "AIX")
        SET_TARGET_PROPERTIES(${EXECUTABLE} PROPERTIES LINK_FLAGS "-Wl,-bbigtoc")
    endif()
    if(${CMAKE_SYSTEM_NAME} STREQUAL "Linux")
        SET_TARGET_PROPERTIES(${EXECUTABLE} PROPERTIES LINK_FLAGS "-Wl,-E")
    endif()
    target_link_libraries(
        ${EXECUTABLE}
        dirac
        ${EXTERNAL_LIBS}
        )
    if(ENABLE_PCMSOLVER)
        add_dependencies(${EXECUTABLE} pcmsolver)
    endif()

    if(ENABLE_STATIC_LINKING)
        target_link_libraries(${EXECUTABLE} ${NODYNEXPORT})
        if (BLAS_TYPE MATCHES Atlas)
            # activate extra linking flags for dirac.x only if this bug occurs, please do not delete
            # http://gcc.gnu.org/bugzilla/show_bug.cgi?id=30471#c7
            # this bug is: signal 11 (SIGSEGV):Segmentation fault, function __restore_rt (0x1613DA0),from file sigaction.c
            target_link_libraries(${EXECUTABLE} -Wl,--whole-archive -lpthread -Wl,--no-whole-archive)
        endif()
        if (BLAS_TYPE MATCHES MKL AND CMAKE_Fortran_COMPILER_ID MATCHES GNU)
            # miro: GNU+MKL-static needs extra lib
            target_link_libraries(${EXECUTABLE} -ldl)
        endif()
    endif()

endforeach()

#miro: add stdc++ library at the very end to satisfy PGI compilers
list(APPEND CMAKE_CXX_IMPLICIT_LINK_LIBRARIES "stdc++")

# give a nice message at the end
include(Motivation)
get_motivational_message(${DEVELOPMENT_CODE} msg)
add_custom_target(final ALL COMMENT "Compilation successfully completed - ${msg}")
set(_list_of_all_targets ${LIST_OF_EXECUTABLES})
if(ENABLE_XCFUN)
    set(_list_of_all_targets ${_list_of_all_targets} example_fortran funeval testall)
endif()
add_dependencies(final ${_list_of_all_targets})
unset(_list_of_all_targets)

#enable compilation of this standalone code with C main source file (TODO: adapt for Portland)
if(ENABLE_HSCC AND CMAKE_Fortran_COMPILER_ID MATCHES Intel)
    SET_TARGET_PROPERTIES(hsmrcc.x PROPERTIES LINK_FLAGS "-nofor-main")
endif()

include(ConfigTesting)
include(ConfigPackaging)

# give information about system, compiler flags, and size of static allocations ...
set(STATIC_MEM_INFO_BINARIES dirac)

# info what blas and lapack will be used when its variable is not set
if(NOT BLAS_LIBRARIES)
    if(USE_BUILTIN_BLAS)
        # builtin library will be used
        set(BLAS_LIBRARIES_INFO "builtin")
    else()
        # none blas
        set(BLAS_LIBRARIES_INFO "none")
    endif()
endif()
if(NOT LAPACK_LIBRARIES)
    if(USE_BUILTIN_LAPACK)
        # builtin library will be used
        set(LAPACK_LIBRARIES_INFO "builtin")
    else()
        # none lapack
        set(LAPACK_LIBRARIES_INFO "none")
    endif()
endif()

# info that there are no explict libraries set
if(NOT EXPLICIT_LIBS)
    set(EXPLICIT_LIBS_INFO "none")
endif()

# configuration time in UTC
execute_process(
    COMMAND ${PYTHON_EXECUTABLE} -c "import datetime; print(datetime.datetime.utcnow())"
    OUTPUT_VARIABLE CONFIGURATION_TIME
)

# delete \n added by Python print()
string(STRIP ${CONFIGURATION_TIME} CONFIGURATION_TIME)

# list with compiler definitions
get_directory_property(_list_of_definitions DIRECTORY ${CMAKE_SOURCE_DIR} COMPILE_DEFINITIONS)

include(BinaryInfo) # giving information - must be called after everything is set
include(ConfigInfo) # has to come after binary info (dependency: git information)

unset(_list_of_definitions)
